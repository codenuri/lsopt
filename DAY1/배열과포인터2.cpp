#include <stdio.h>

int main()
{
	int x[3] = { 1,2,3 };

	// 아래 2줄의 차이점을 생각해 보세요
	int(*p1)[3] = &x;

	int* p2 = x; // array to pointer conversion 문법(decay)
				 // "배열의 이름은 배열의 "1번째 요소의 주소"로
				 // 암시적 변환된다."



	// 모든 포인터 변수의 메모리 모양은 결국 동일합니다.
	// => 주소만 담기 때문에. 항상 같은 크기
	
	// 그럼, 포인터의 타입이 가지는 의미는 무엇일까요 ?
	// => 포인터 변수에 *, + 등의 연산을 했을때 해석하는 방법을
	//    알려주는것

	// 위 코드에서 p1, p2는 결국 같은 주소를 가리킵니다.
	// 하지만, p1, p2 에 연산자를 적용시 결과가 달라 집니다

	printf("%p, %p\n", p1, p1 + 1); // ?
	printf("%p, %p\n", p2, p2 + 1); // ?

	// 아래 코드의 의미를 생각해 보세요

	*p2 = 10; // *(배열의 1번째요소주소) = 10
			  // "배열의 1번째 요소" = 10 이므로 ok

//	*p1 = 10; // *(배열의 주소) = 10
			  // "배열" = 10 이 되므로 error

	*p1[0] = 10; // *(배열의 주소)[0] = 10
				// 배열[0] = 10 이므로 ok
}